% This will be the main document for the Technical Networks paper to
% be written by the Eggnet team of Jordan Ell, Triet Huynh and Braden
% Simpson in association with Adrian Schroeter and Daniela Damian.

\documentclass[conference]{IEEEtran}

% Use of outside images
\usepackage{graphicx} 

% Correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

% Begin the paper here
\begin{document}


% Paper title
% Can use linebreaks \\ within to get better formatting as desired
\title{Finding Harmful Structures Among Developer Networks}

% Authors names
\author{\IEEEauthorblockN{Jordan Ell,
Triet Huynh,
Braden Simpson, 
Adrian Schr{\"o}ter and
Daniela Damian}
\IEEEauthorblockA{University of Victoria,
Victoria, British Columbia\\\{jell, infiro, braden\}@uvic.ca, schadr@acm.org, danielad@cs.uvic.ca}
%\IEEEauthorblockA{\IEEEauthorrefmark{2}University of Victoria\\
%Victoria, British Columbia\\ infiro@uvic.ca}
%\IEEEauthorblockA{\IEEEauthorrefmark{3}University of Victoria\\
%Victoria, British Columbia\\ braden@uvic.ca}
%\IEEEauthorblockA{\IEEEauthorrefmark{4}University of Victoria\\
%Victoria, British Columbia\\ schadr@uvic.ca}
%\IEEEauthorblockA{\IEEEauthorrefmark{5}University of Victoria\\
%Victoria, British Columbia\\ danielad@cs.uvic.ca}}
}

% Make the title area
\maketitle


\begin{abstract}
Software systems have not only become larger over time, but the amount of
technical contributors and dependencies have also increased. With these expansions also comes
the increasing risk of introducing a software failure into a pre-existing system.
Software failures are a multi-billion dollar problem in the industry today and while integration and
other forms of testing are helping to ensure a minimal number of failures, research to understand
full impacts of changesets and their social implications is still a major concern. This paper describes
how analysis of changesets and the technical relationships they infer can be used to detect harmful
structures between contributors which may induce software failures. The result of these predictions
also provide a communication recommendation per changeset that supports the notion of
socio-technical congruence which is know to increase changeset success.
\end{abstract}


\section{Introduction}

% Setup the problem.
Large software projects are created using highly modular and 
reusable code. The problem this creates, is that methods or functions\footnote{This includes object constructors} 
can be used in a wide variety of locations throughout the project creating many technical 
dependencies.  This causes changes to any given method inside the project to have a rippling 
effect across the rest of the project~\cite{Acharya:2011:PCI}. The larger these effects are,
the more likely they are to cause a software failure inside the system during the project's
life span~\cite{Zimmermann:2008:PDU}. These observations open the door to many types
of network analysis in regard to technical dependencies and preventing software failures.

% Explain technical network research that already exists
Technical dependencies inside a project can be used to predict success or failure of 
changesets or builds~\cite{Pinzger:2008:DNP, Zimmermann:2008:PDU}. However, most 
research in this area is based off of identifying
central modules inside of a large code base which are likely to cause software failures and 
predicting future failures based on this knowledge. This method also results in predictions 
at the milestone build level of software development as opposed to a changeset level.
These research projects also lack the ability to provide recommendations.

% Introduce the idea of socio-technical congruence
Changeset failures are often also associated with the notion of a socio-technical 
congruence inside of a project~\cite{Conway:1968}. Kwan et al.~\cite{Kwan:2011:SD} shows, 
that if the build type is continuous (changesets over time), an increased level of this
congruence led to an increase in the build success probability.

% Research question
With the power of technical dependencies in predicting software failures and the idea
that socio-technical congruence can help changeset success we pose the question: 
"\textit{Is it possible to locate harmful dependency structures among contributors inside
of changesets with technical dependencies and can we provide recommendations to help
solve issues these structures create?}"

% Explain our brief intended approach
This paper explains our attempt to create a failure prediction system on a per changeset basis using
the detection of harmful structures among developer networks.
Our process utilizes changesets and the call hierarchies effected  to find patterns of contributor 
relationships in successful and failed changesets.  We can use these contributor relationships 
to also promote the idea of socio-technical congruence with communications recommendations.


\section{Methodology}

\subsection{Determining Changeset Success or Failure}
In order to determine whether a previous commit was a success or failure (introduces a software
failure), we use the approach of Sliwerski et al.~\cite{Sliwerski:2005:CIF}.

\subsection{Extracting Technical Networks}
To extract the technical dependencies of a project given a changeset, we construct a method
call graph using Eclipse's ASTParser. 
Unlike  Bodden's et al.~\cite{Bodden:2003:HVJ} and other's approaches of using byte code
and whole projects, we built our call graphs using source code, which does not have the assumptions
of being able to compile or have access to all project files.

We then use a tool similar to the Unix \textit{diff} command to figure out what changes we made 
to any given file inside of the changeset in question. From here, we determine the methods, 
and weight of each method in terms of its total characters , that have been changed.

Combining the call graph and the given method changes of the changeset from the \textit{diff} like 
command,  we can determine what methods call those which have been changed. This creates a 
technical dependency between the two methods.

From the method caller to callee relationships, we can infer the contributors by using
the Git \textit{blame} command. From the \textit{blame}, we can gather information regarding which 
contributor  wrote which lines of code inside a method. We then gather all contributors of the 
caller method inside the technical relationship and create an edge between them and 
the author of the changeset, who is the contributor for the 
callee (changed) method. To weight the edges, we use the formula:

\begin{equation}\label{first}
W = (\frac{\frac{\delta}{T_{1}}*\frac{O}{T_{2}}}{D})*100
\end{equation}

Here, $\frac{\delta}{T_{1}}$ is the percent of method changed by the callee and $\frac{O}{T_{2}}$ 
is the percent owned of the caller method. All of this is divided by the caller depth away from 
the callee (most cases 1).  Our technical networks are now created. We store all network data for
previous commits inside the project.

\begin{figure}[tb!]
\centering
\includegraphics[width=0.5\columnwidth]{images/network}
\caption{A technical network. Contributor A has changed code which contributors B, C and D 
are calling from their own code}
\end{figure}

\subsection{Predicting Success or Failure And Recommendations}
Given a new changeset to a project, we are able to extract all the contributor networks as described
above. After which, we look into the project's past networks to determine if any of the contributor edges have
occurred before and whether or not that edge has a  corresponded to more successful or failed changeset. 

We can now base our prediction of whether a changeset will fail based on this data and we can recommend
high failure rate pairs of contributors communicate during a predicted failed changeset to support the notion
of socio-technical congruence.

\section{Results}
For this paper, we choose to study the Hibernate-ORM project which is an open source Java 
application hosted on GitHub\footnote{https://github.com/}. The issue tracking for this 
project is performed by Jira\footnote{http://www.atlassian.com/software/jira/overview}.

We chose this project because it utilizes Java for all internal structures and control flow which
is ideal for creating large method call graphs. This project is also source controlled with Git
which allows the use of Git's provided tools for traversing the repository and mining
information. Finally, Hibernate-ORM uses issue tracking software which can easily be mined
using a provided API which is ideal for determining changeset success or failure.

In Hibernate-ORM, we found a total of X contributor pairs existed over the entire project, 
of which Y were found to cause failures inside of the system. We rank failures by the ratio 
of successful to failed changesets in which they were found (Table\ref{tab:ratio}).

\begin{table}[h]
\begin{center}
\begin{tabular}{@{\hspace{.2cm}}ccc@{\hspace{.75cm}}c@{\hspace{.2cm}}}
\hline
Pair & Successful & Failed & Ratio\\
\hline
(Cody, Daisy)	&	0&	12&	1		\\
(Adam, Daisy)	&	1&	14&	0.9697	\\
(Bart, Eve)	&	2&	11&	0.9265      \\
\hline
\end{tabular}
\end{center}
\caption{The top 3 harmful contributor pairs found and ordered by failure ratio.\label{tab:ratio}}
\end{table}

Using this data, we were able to accurately predict W out of Z failures from a sample size of T given
changesets inside our test project. From these predicted failures we were able to give an average of
H recommendations for contributor communication on average.


\section{Conclusion and Future Work}
Technical dependencies are often used to predict software failures
in large software system~\cite{Pinzger:2008:DNP, Zimmermann:2008:PDU}. 
We have found evidence that technical dependencies predict failures based on contributor
dependencies found in changesets. Through the contributor dependencies,
we can also give recommendations to contributors about whom to contact to
resolve potential issues.

In future work, we will add communication networks on a per commit basis as well. We plan
to investigate the congruence of these social and technical networks and its effects on 
software quality.



\bibliographystyle{IEEEtran}
\bibliography{paper}


% End of the paper
\end{document}
